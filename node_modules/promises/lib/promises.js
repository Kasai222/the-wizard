// Generated by CoffeeScript 1.6.3
var Deferred, Promise, args, promises,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __slice = [].slice,
  __hasProp = {}.hasOwnProperty;

promises = typeof exports !== 'undefined' ? exports : this;

Promise = (function() {
  function Promise() {
    this.call = __bind(this.call, this);
  }

  Promise.prototype.then = function(resolvedHandler, rejectedHandler, progressHandler, cancelHandler) {
    throw new TypeError('The Promise base class is abstract, this function is overwritten by the promise\'s deferred object');
  };

  Promise.prototype.resolved = function(handler) {
    return this.then(handler);
  };

  Promise.prototype.done = function(handler) {
    return this.then(handler);
  };

  Promise.prototype.rejected = function(handler) {
    return this.then(null, handler);
  };

  Promise.prototype.always = function(handler) {
    var rejectedHandler, resolvedHandler;
    resolvedHandler = function(res) {
      return handler(null, res);
    };
    rejectedHandler = function(err) {
      return handler(err);
    };
    return this.then(resolvedHandler, rejectedHandler);
  };

  Promise.prototype.progress = function(handler) {
    return this.then(null, null, handler);
  };

  Promise.prototype.canceled = function(handler) {
    return this.then(null, null, null, handler);
  };

  Promise.prototype.apply = function(handler, context) {
    return this.then(function(result) {
      if ((result instanceof Array)(handler.apply(context || this, result))) {

      } else {
        return handler.call(context || this, result);
      }
    });
  };

  Promise.prototype.cancel = function() {
    throw new TypeError('The Promise base class is abstract, this function is overwritten by the promise\'s deferred object');
  };

  Promise.prototype.get = function(propertyName) {
    return this.then(function(object) {
      return object != null ? object[propertyName] : void 0;
    });
  };

  Promise.prototype.set = function(propertyName, value) {
    return this.then(function(object) {
      if (object != null) {
        object[propertyName] = value;
      }
      return object;
    });
  };

  Promise.prototype.put = function(propertyName, value) {
    return this.then(function(object) {
      return object != null ? object[propertyName] = value : void 0;
    });
  };

  Promise.prototype.run = function() {
    var functionName, params;
    functionName = arguments[0], params = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    return this.then(function(object) {
      if (object != null) {
        object[functionName].apply(object, params);
      }
      return object;
    });
  };

  Promise.prototype.call = function() {
    var functionName, params;
    functionName = arguments[0], params = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    return this.then(function(object) {
      return object[functionName].apply(object, params);
    });
  };

  return Promise;

})();

['pop', 'shift', 'splice', 'filter', 'every', 'map', 'some'].forEach(function(method) {
  return Promise.prototype[method] = function() {
    var args;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return this.then(function(object) {
      return object != null ? typeof object[method] === "function" ? object[method].apply(object, args) : void 0 : void 0;
    });
  };
});

['push', 'reverse', 'sort', 'unshift', 'forEach'].forEach(function(method) {
  return Promise.prototype[method] = function() {
    var args;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return this.then(function(object) {
      if (object instanceof Array) {
        object[method].apply(object, args);
      }
      return object;
    });
  };
});

Promise.extend = function(methods) {
  var SubPromise, name, value;
  SubPromise = function() {};
  SubPromise.extend = this.extend;
  SubPromise.prototype = new this();
  if (methods) {
    for (name in methods) {
      if (!__hasProp.call(methods, name)) continue;
      value = methods[name];
      SubPromise.prototype[name] = value;
    }
  }
  return SubPromise;
};

promises.when = function() {
  var alwaysCallback, count, createCallback, deferred, name, obj, params, rejected, rejectedCallback, resolvedCallback, _i, _len;
  params = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
  deferred = promises.defer();
  count = params.length;
  rejected = false;
  resolvedCallback = function() {};
  rejectedCallback = function(value) {
    rejected = true;
    return value;
  };
  createCallback = function(index) {
    return function() {
      var results;
      results = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      params[index] = results.length > 1 ? results : results[0];
      if (--count === 0) {
        if (rejected) {
          return deferred.reject.apply(deferred, params);
        } else {
          return deferred.resolve.apply(deferred, params);
        }
      }
    };
  };
  for (name = _i = 0, _len = params.length; _i < _len; name = ++_i) {
    obj = params[name];
    if (obj && typeof obj.then === 'function') {
      alwaysCallback = createCallback(name);
      obj.then(resolvedCallback, rejectedCallback);
      obj.then(alwaysCallback, alwaysCallback);
    } else {
      --count;
    }
  }
  if (count === 0) {
    deferred.resolve.apply(deferred, params);
  }
  return deferred.promise;
};

args = function() {
  var params;
  params = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
  params.isArgs = true;
  return params;
};

Deferred = (function() {
  function Deferred(promise) {
    if (promise == null) {
      promise = new promises.Promise;
    }
    this.progress = __bind(this.progress, this);
    this.cancel = __bind(this.cancel, this);
    this.reject = __bind(this.reject, this);
    this.resolve = __bind(this.resolve, this);
    this.finished = __bind(this.finished, this);
    this.then = __bind(this.then, this);
    this.promise = promise;
    this.status = 'pending';
    this.progressHandlers = [];
    this.handlers = [];
    promise.then = this.then;
    promise.cancel = this.cancel;
  }

  Deferred.prototype.then = function(resolvedHandler, rejectedHandler, progressHandler, canceledHandler) {
    var nextDeferred;
    if (progressHandler) {
      this.progressHandlers.push(progressHandler);
    }
    nextDeferred = promises.defer();
    nextDeferred.promise.prev = this.promise;
    this._addHandler(resolvedHandler, rejectedHandler, canceledHandler).nextDeferred = nextDeferred;
    if (this.finished()) {
      this._notify(this.handlers.pop());
    }
    return nextDeferred.promise;
  };

  Deferred.prototype.finished = function() {
    return this.status !== 'pending';
  };

  Deferred.prototype.resolve = function() {
    var params, _ref;
    params = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    if ((_ref = params[0]) != null ? _ref.isArgs : void 0) {
      params = params[0];
    }
    return this._finish('resolve', params);
  };

  Deferred.prototype.reject = function() {
    var params, _ref;
    params = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    if ((_ref = params[0]) != null ? _ref.isArgs : void 0) {
      params = params[0];
    }
    return this._finish('reject', params);
  };

  Deferred.prototype.cancel = function() {
    var params, _ref, _ref1;
    params = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    if ((_ref = params[0]) != null ? _ref.isArgs : void 0) {
      params = params[0];
    }
    this._finish('cancel', params);
    return (_ref1 = this.promise.prev) != null ? _ref1.cancel() : void 0;
  };

  Deferred.prototype.progress = function() {
    var params, progress, _i, _len, _ref, _results;
    params = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    _ref = this.progressHandlers;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      progress = _ref[_i];
      _results.push(progress.apply(null, params));
    }
    return _results;
  };

  Deferred.prototype.timeout = function(milliseconds, error) {
    var _this = this;
    clearTimeout(this._timeout);
    return this._timeout = setTimeout(function() {
      return _this.reject(error != null ? error : new Error('Operation timed out'));
    }, milliseconds);
  };

  Deferred.prototype.reset = function() {
    this.status = 'pending';
    this.progressHandlers = [];
    return this.handlers = [];
  };

  Deferred.prototype._finish = function(status, results) {
    var handler, _results;
    if (this.status !== 'pending') {
      return;
    }
    clearTimeout(this._timeout);
    this.status = status;
    this.results = results;
    _results = [];
    while ((handler = this.handlers.shift())) {
      _results.push(this._notify(handler));
    }
    return _results;
  };

  Deferred.prototype._notify = function(handler) {
    var deferred, method, nextResult, results;
    results = this.results;
    method = handler[this.status];
    deferred = handler.nextDeferred;
    if (!method) {
      if (deferred) {
        deferred[this.status].apply(deferred, results);
      }
      return;
    }
    nextResult = method.apply(null, results);
    if (nextResult && typeof nextResult.then === 'function') {
      return nextResult.then(deferred.resolve, deferred.reject);
    } else {
      return deferred[this.status](nextResult);
    }
  };

  Deferred.prototype._addHandler = function(resolvedHandler, rejectedHandler, canceledHandler) {
    var handler;
    handler = {
      resolve: resolvedHandler,
      reject: rejectedHandler,
      cancel: canceledHandler
    };
    this.handlers.push(handler);
    return handler;
  };

  return Deferred;

})();

if (!Function.prototype.bind) {
  Function.prototype.bind = function() {
    var bound, nop, obj, params, self;
    obj = arguments[0], params = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    self = this;
    nop = function() {};
    bound = function() {
      var localParams, _ref;
      localParams = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return self.apply((_ref = this instanceof nop) != null ? _ref : {
        "this": obj != null ? obj : {}
      }, params.concat(localParams));
    };
    nop.prototype = self.prototype;
    bound.prototype = new nop();
    return bound;
  };
}

promises.Deferred = Deferred;

promises.Promise = Promise;

promises.args = args;

promises.defer = function(promise) {
  return new promises.Deferred(promise);
};

promises.wrap = function(method, PromiseClass) {
  return function() {
    var args, callback, deferred, promise;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    promise = PromiseClass ? new PromiseClass() : void 0;
    deferred = promises.defer(promise);
    if (typeof args[args.length - 1] === 'function') {
      callback = args.pop();
    }
    args.push(function() {
      var err, results;
      err = arguments[0], results = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      if (callback) {
        callback.apply(null, [err].concat(__slice.call(results)));
      }
      if (err) {
        return deferred.reject(err);
      } else {
        return deferred.resolve.apply(deferred, results);
      }
    });
    method.apply(this, args);
    return deferred.promise;
  };
};

promises.resolve = function() {
  var args, deferred;
  args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
  deferred = promises.defer();
  deferred.resolve.apply(deferred, args);
  return deferred.promise;
};

promises.reject = function() {
  var args, deferred;
  args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
  deferred = promises.defer();
  deferred.reject.apply(deferred, args);
  return deferred.promise;
};

if (typeof exports !== 'undefined') {
  promises.fs = require('./fs');
}
